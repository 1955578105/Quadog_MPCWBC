1. go2 的mjcf 建模， body 的方向 正好符合 论文中的方向 即  当所有 关节角度为0时， Z轴向上 ，X轴向前
   世界坐标轴也满足要求。
2. mujoco 中  RGB -> XYZ   轴的颜色对应轴

3.四元数 得到旋转矩阵的公式
R = [
    [1 - 2*y² - 2*z²,     2*x*y - 2*w*z,     2*x*z + 2*w*y],
    [2*x*y + 2*w*z,       1 - 2*x² - 2*z²,   2*y*z - 2*w*x],
    [2*x*z - 2*w*y,       2*y*z + 2*w*x,     1 - 2*x² - 2*y²]
]


4.  头文件中的static变量 每个包含头文件的.cpp都有独立副本
    头文件中的inline变量 永远只有一个实体 没有副本


5.  后期完善 数据可视化  和  多线程
#include <chrono>
#include <thread>

void control_thread() {
    using namespace std::chrono;
    // 获取当前时间作为起点
    auto next_wakeup = high_resolution_clock::now();
    
    while (running) {
        // 1. 执行控制算法 (MPC/WBC)
        do_control();

        // 2. 设定下一次唤醒的绝对时间点：精准的 1ms 后
        next_wakeup += microseconds(1000); 
        
        // 3. 睡到那个绝对时间点
        // 即使 do_control 耗时 0.4ms 或 0.6ms，唤醒时间点永远是固定的
        std::this_thread::sleep_until(next_wakeup);
    }
}



6.给机械狗设计一个姿态 ： PD控制器 ， 对每一个关节而言  ， 进行多项式插值（机器人学中的方法） ，得到每个时刻的目标位置与速度，可让结果丝滑；
### 1. 为什么 PDF 论文里算出来是“三次函数”？
**原因在于它定义的“泛函”标准较低。**

*   **PDF 的逻辑：** 论文定义的泛函是 $J = \int (\ddot{x})^2 dt$（最小化加速度的平方）。
*   **数学推导：** 对加速度平方积分求变分，得到的是四阶导数为 0（$\frac{d^4x}{dt^4} = 0$），积分四次，确实是**三次多项式**。
*   **适用场景：** 这种方法能保证**速度连续**。在仿真软件（如 Webots, Gazebo）里，由于物理引擎是理想化的，没有真实电机的电流纹波和减速器的齿轮间隙，三次函数跑起来非常漂亮。

### 2. 为什么在工程实践中我建议你用“五次函数”？
**原因在于真实的机械狗有“脾气”（物理特性）。**

*   **痛点：** 三次函数虽然速度连续，但**加速度不连续**。在 $t=0$ 的瞬间，加速度会从 0 瞬间跳变到一个数值。
*   **后果：** 
    *   根据 $F=ma$，加速度跳变意味着电机的扭矩（电流）也要瞬间跳变。
    *   **振动：** 这种跳变会激发起机械腿的自振频率，你会看到狗腿在启动瞬间抖一下。
    *   **磨损：** 减速器内部的齿轮会在瞬间受到冲击，长期下来会造成齿轮磨损或断裂。
*   **解决：** 如果我们将泛函定义为 $J = \int (\dddot{x})^2 dt$（最小化 Jerk，即加加速度的平方），根据变分法推导，就会得到六阶导数为 0（$\frac{d^6x}{dt^6} = 0$），积分后就是**五次多项式**。

// 控制上====================================================


这是一个非常专业且切中要害的问题。

简单直接的回答是：**在控制闭环中，通常不需要加上“加速度误差”的反。但是，你必须把 5 次多项式算出来的“期望加速度”作为“前馈（Feedforward）”项加到控制输出中。**

为了让你彻底理解为什么要这么做，我们从**传感器噪声**和**动力学补偿**两个维度来分析：

### 1. 为什么不加“加速度误差”作为反馈？
在控制理论中，我们常用的 PD 控制器是这样的：
$$\tau = k_p(q_d - q) + k_d(\dot{q}_d - \dot{q})$$
如果你想加一个加速度项 $k_a(\ddot{q}_d - \ddot{q})$，你会遇到两个严重的问题：

*   **传感器噪声（最致命）：** 机械狗的编码器测量的是**角度 $q$**。
    *   对角度求一次导得到速度 $\dot{q}$，信号已经有点毛刺了。
    *   对角度求**两次导**得到加速度 $\ddot{q}$，信号会变得极其嘈杂（噪声会被放大成百上千倍）。
    *   如果你把这个充满噪声的信号反馈给电机，电机会发出刺耳的“滋滋”声，甚至剧烈发热震动。
*   **相位滞后：** 采样和求导过程会产生滞后，加速度反馈往往会让系统变得更不稳定。

### 2. 为什么一定要用“期望加速度”做前馈？
虽然不加误差反馈，但 5 次多项式算出的 $\ddot{q}_d(t)$ 是宝贝，它是**前馈控制**的核心。

根据牛顿第二定律 $F = ma$（在机器人里是 $\tau = M(q)\ddot{q} + \dots$），如果你想让关节产生 $\ddot{q}_d$ 的加速度，电机必须立即输出一部分扭矩来克服惯性。

**你应该采用的控制律（Feedforward + Feedback）：**
$$\tau_{output} = \underbrace{M(q) \cdot \ddot{q}_d}_{\text{加速度前馈}} + \underbrace{k_p(q_d - q) + k_d(\dot{q}_d - \dot{q})}_{\text{位置/速度反馈}}$$

*   **前馈的作用：** 它告诉电机：“嘿，根据计划，我现在马上要开始加速了，你先出这点力顶上去。”这样 PD 反馈项就不需要等产生误差了才出力，机械狗的动作会非常**“跟手”**，延迟感极低。
*   **5次多项式的优势：** 因为 5 次多项式的 $\ddot{q}_d$ 是连续且平滑的，所以你的前馈扭矩也是平滑的。这正是保护减速器的关键！

---

### 3. 结合 PDF 中的 WBC（全身控制）框架
你看的 PDF 论文第 74 页（公式 4.62）提到了关节扭矩指令：
$$\tau^{cmd} = \tau_j + k_p(q_j^{cmd} - q_j) + k_d(\dot{q}_j^{cmd} - \dot{q}_j)$$

这里的 $\tau_j$ 实际上就是通过**期望加速度**算出来的动力学项。在 WBC 框架下，流程是这样的：
1.  **5 次多项式**给出：$q_d, \dot{q}_d, \ddot{q}_d$。
2.  **期望加速度 $\ddot{q}_d$** 作为“任务加速度”输入给 WBC。
3.  **WBC 通过动力学方程**算出一个抵消重力和惯性的基础扭矩 $\tau_j$。
4.  **PD 闭环**处理微小的偏差。

### 总结建议：
1.  **反馈层（Feedback）：** 只保留**角度误差**和**角速度误差**（PD控制）。千万不要对传感器的加速度求导做反馈。
2.  **前馈层（Feedforward）：** 必须利用 5 次多项式给出的 $\ddot{q}_d$。
    *   如果你有准确的动力学模型，用 $M(q)\ddot{q}_d$。
    *   如果你没有模型，甚至可以简单地给 $\ddot{q}_d$ 乘上一个增益系数作为扭矩补偿。
3.  **轨迹连续性：** 这就是为什么选 5 次多项式的原因——它保证了你给电机的**扭矩前馈项**在启动和停止那一刻是 $0$，并且中间是平滑过渡的。

**操作方案：**
你在写代码时，函数应该返回一个结构体，包含 `pos`, `vel`, `acc`。控制循环读取这三个值，`pos` 和 `vel` 喂给 PD，`acc` 喂给动力学补偿单元。这样你的机械狗归位动作会像丝绸一样顺滑。